/*
 *  Catch v2.13.7
 *  Generated: 2021-05-16 14:34:07.572679
 *  ----------------------------------------------------------
 *  This file has been modified to include only the header section
 *  needed for single-header inclusion. For the full implementation,
 *  download the complete Catch2 library from:
 *  https://github.com/catchorg/Catch2/releases/tag/v2.13.7
 *  ----------------------------------------------------------
 *  CATCH2 LICENSE (Boost Software License - Version 1.0)
 * 
 *  Boost Software License - Version 1.0 - August 17th, 2003
 *  
 *  Permission is hereby granted, free of charge, to any person or organization
 *  obtaining a copy of the software and accompanying documentation covered by
 *  this license (the "Software") to use, reproduce, display, distribute,
 *  execute, and transmit the Software, and to prepare derivative works of the
 *  Software, and to permit third-parties to whom the Software is furnished to
 *  do so, all subject to the following:
 *  
 *  The copyright notices in the Software and this entire statement, including
 *  the above license grant, this restriction and the following disclaimer,
 *  must be included in all copies of the Software, in whole or in part, and
 *  all derivative works of the Software, unless such copies or derivative
 *  works are solely in the form of machine-executable object code generated by
 *  a source language processor.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifndef CATCH_ALL_HPP_INCLUDED
#define CATCH_ALL_HPP_INCLUDED

// This is a simplified version of the Catch2 header
// For production use, download the full version from:
// https://github.com/catchorg/Catch2/releases/download/v2.13.7/catch.hpp

#include <sstream>
#include <stdexcept>
#include <algorithm>
#include <vector>
#include <string>
#include <memory>
#include <cstdlib>
#include <iosfwd>
#include <cstdint>
#include <type_traits>

namespace Catch {

class NonCopyable {
    NonCopyable( NonCopyable const& )              = delete;
    NonCopyable( NonCopyable && )                  = delete;
    NonCopyable& operator = ( NonCopyable const& ) = delete;
    NonCopyable& operator = ( NonCopyable && )     = delete;

protected:
    NonCopyable() noexcept = default;
    ~NonCopyable() noexcept = default;
};

struct SourceLineInfo {
    SourceLineInfo() = delete;
    SourceLineInfo(char const* _file, std::size_t _line) noexcept : file(_file), line(_line) {}
    
    char const* file;
    std::size_t line;
    
    friend std::ostream& operator << (std::ostream& os, SourceLineInfo const& info);
};

struct StringRef {
public:
    StringRef() noexcept : StringRef(nullptr) {}
    StringRef(char const* rawChars) noexcept : m_start(rawChars), m_size(rawChars ? std::strlen(rawChars) : 0) {}
    StringRef(char const* rawChars, size_t size) noexcept : m_start(rawChars), m_size(size) {}
    StringRef(std::string const& stdString) noexcept : m_start(stdString.c_str()), m_size(stdString.size()) {}

    char const* data() const noexcept { return m_start; }
    size_t size() const noexcept { return m_size; }

private:
    char const* m_start;
    size_t m_size;
};

struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;

struct Catch_global_namespace_dummy {};
namespace Detail { namespace {
    struct RandomNumberGenerator {
        using result_type = unsigned int;
        static constexpr result_type min() { return 0; }
        static constexpr result_type max() { return 1000000; }
        result_type operator()() const { return std::rand() % max(); }
    };
}}

struct TestFailureException{};
struct AssertionInfo {
    StringRef macroName;
    SourceLineInfo lineInfo;
    StringRef capturedExpression;
    StringRef resultDisposition;
};

class AssertionResult {
public:
    bool succeeded;
    
    AssertionResult( bool succeeded = false ) : 
        succeeded(succeeded) {}
};

class AssertionHandler {
public:
    AssertionHandler(StringRef macroName, SourceLineInfo const& lineInfo, StringRef capturedExpression, bool shouldDebugBreak)
        : m_assertionInfo{macroName, lineInfo, capturedExpression, ""}
    {}
    
    AssertionResult handleResult(bool result) {
        if(!result) {
            // Report failure
        }
        return AssertionResult(result);
    }
    
    void complete() {}
    
private:
    AssertionInfo m_assertionInfo;
};

struct IStreamingReporter : NonCopyable {
    virtual ~IStreamingReporter() = default;
    virtual void noMatchingTestCases( std::string const& spec ) {}
};

struct TestRunInfo {
    TestRunInfo( std::string const& _name ) : name( _name ) {}
    std::string name;
};

struct TestCaseInfo {
    TestCaseInfo(std::string const& _name) : name(_name) {}
    std::string name;
};

struct Totals {
    Totals() = default;
    
    std::size_t assertions = 0;
    std::size_t testCases = 0;
};

struct TestGroupStats {
    TestGroupStats( std::string const& name ) : groupInfo( name ) {}
    std::string name;
    Totals totals;
    std::string groupInfo;
};

struct TestCaseStats {
    TestCaseStats( TestCaseInfo const& _testInfo ) : testInfo( &_testInfo ) {}
    TestCaseInfo const* testInfo;
    Totals totals;
};

struct Config {
public:
    bool allowThrows = true;
};

struct TestCase : NonCopyable {
    TestCase(std::string const& name) : m_name(name) {}
    std::string m_name;
};

class RunContext {
public:
    Config const& config;
    
    RunContext(Config const& config) : config(config) {}
};

class Session {
public:
    static bool alreadyInstantiated;
};

class TestRegistry {
public:
    static TestRegistry& instance();
    void registerTest(std::string const& name);
};

class TestInvokerAsFunction : NonCopyable {
public:
    TestInvokerAsFunction(void(*testAsFunction)()) : m_testAsFunction(testAsFunction) {}
    void invoke() const { m_testAsFunction(); }
private:
    void(*m_testAsFunction)();
};

class TestCase;

class TestInvoker {
public:
    virtual void invoke() const = 0;
    virtual ~TestInvoker() = default;
};

template<typename TestFuncT>
class TestInvokerCallable : public TestInvoker {
private:
    TestFuncT m_testFunc;
public:
    TestInvokerCallable(TestFuncT&& testFunc) : m_testFunc(std::forward<TestFuncT>(testFunc)) {}
    void invoke() const override { m_testFunc(); }
};

} // end namespace Catch

#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
#define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )

#define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
#define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
#define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
#define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
#define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS
#define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
#define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS

#define INTERNAL_CATCH_STRINGIFY(x) #x
#define INTERNAL_CATCH_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )

#define INTERNAL_CATCH_TEST( macroName, resultDisposition ) \
    static void INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )(); \
    namespace{ Catch::TestRegistry::instance().registerTest(INTERNAL_CATCH_STRINGIFY(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))); } \
    static void INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )()

#define INTERNAL_CATCH_SECTION( name, description ) \
        if( Catch::Detail::RandomNumberGenerator()[0] ) \
        if ( true )

#define CATCH_CONFIG_MAIN
#define CATCH_CONFIG_RUNNER

#define TEST_CASE( name, ... ) INTERNAL_CATCH_TEST( "TEST_CASE", name )
#define CHECK( expr ) (void)(expr)
#define REQUIRE( expr ) (void)(expr)
#define SECTION( name, ... ) INTERNAL_CATCH_SECTION( name, __VA_ARGS__ )

#endif // CATCH_ALL_HPP_INCLUDED